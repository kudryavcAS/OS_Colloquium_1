1.	ООП
	ООП - объектно-ориентированное программирование - наиболее часто определяется как методология программирования,
	при которой программа рассматривается как совокупность взаимодействующих объектов. 
	Ключевые принципы ООП — это абстракция, инкапсуляция, наследование и полиморфизм. При более близком рассмотрении, например, простейшего случая 
	инкапсуляции на примере одного поля можно земетить что число строк кода возрасло, а поле всё ещё можно читать и изменять (сеттеры, геттеры). 
	Получается что инкапсуляция в первую очередь нужна для сокрытия изменчивости, а не сложности. Так, например, может понадобится внедрить
	более сложную логику вычисления данного поля, для чего будет достаточно изменить реализацию геттеров и сеттеров, вызываемых в коде.
	Наследоваение и полиморфизм можно рассматривать как частный случай инкапсуляции. При дальнейшом рассмотрении можно придти к выводу, что
	ООП, в первую очередь, - инструмент борьбы с доменной сложностью.

2.	Объектно-ориентированная декомпозиция.	
	Объектно-ориентированная декомпозиция - декомпозиция, при которой проектируемая система логически представляется в виде суммы 
	отдельных частей (средствами ООП), взаимодействующих между собой. Часто эта декомпозиция производится не произвольно, а 
	по определённым шаблонам, с помощью использованием нескокльких десятков популярных 
	шаблонов проектирования (design patterns).

3.	Дизайн ПО
	Дизайн ПО - это план, иначе говоря, структура компонентов системы, определяющая их взаимодействие и распределение ответственности 
	для управления сложностью и достижения требуемых характеристик.
	Примеров дизайна ПО могут служить шаблоны проектирования (design patterns). Они задают струткуру компонентов (данных, классов)
	и их взаимодействия. Рассмотрим дизайн на примере поведенческого паттерна Стратегия, который определяет семейство схожих алгоритмов 
	и помещает каждый из них в собственный класс, после чего алгоритмы можно взаимозаменять прямо во время исполнения программы.
	1) Структурный дизайн - из чего состоит система. Может быть один класс/алгоритм имеющий много мктодов для разных входных данных и сложную 
	логику их выбора, а можно задать интерфейс и унаследовать от него конкретные узкоспециализированные классы (выполняется принцип разделения
	ответственности, своего рода реализации стратегии "разделяй и властвуй")
	2) Поведенческий дизайн - дизайн взаимодействия компонентов (наследование, включение и т.д.). Паттерн Стратегия позволяет динамически
	менять поведение. например метод
			setStrategy(Strategy strategy) {
				this.strategy = strategy;
			}
	3) Дизайн сопутсвует расширяемости функционала - легко добавить ещё один класс, реализующий конктреный алгоритм.

4.	Магическое число 7 
	Магическое число 7 (+-2, далее если написано 7 имеется ввиду [5;9]) Миллера - правило, согласно которому мозг человека 
	одновременно может оперировать не более чем 7 сущностями.
	Поэтому не нужно перегружать пользователя/разработчика, или просто человека который будет читать код большим количетсвом элементов, условий,
	сущностей и т.д. Например:
	1) Меню. Ограничивать количество пунктов меню, чтобы пользователь "не терялся".
	2) Функция/метод не должна принимать много параметров. Желательно - не больше 3, но если вдруг больше 7 - ай нехорошо.
	3) Логическая и визуальная группировка элементов - имеет смысл разбивать элементы (желательно по какой-то логике) на группы по 7 элементов
	4) Длина функции/метода. 7-10 строк кода - хороший вариант
	5) Количетсво полей в классе, структуре - большое количетсво полей в классе, или переменных в функции/main может усложнять читаемость кода
	6) x86 32-битный процессор: 8 основных регистров (EAX, EBX, ECX, EDX, ESI, EDI, EBP, ESP). Что это если не число Миллера? 
	7) Количество условий в условных выражениях - даже 7 как-то много. Желательно не больше 2-3.

5.	5 признаков сложных систем по Гради Бучу. 
	Далее следуют сами признаки и примеры - браузер, ОС, 
	1) Сложные системы часто являются иерархичными и состоят из связанных подсистем.
	Так, в браузере: 1 - Сам браузер, 2 - Движок рендеринга, движок JavaScript(в большинстве браузеров) 
	подсистема управления вкладками.3 - парсер HTML, CSS, механизм вычисления layout (расчёт расположения элементов) и т.д
	ОС - самый очевидный пример: 1 - Вся ОС. 2 -  Ядро, подсистемы пользовательского пространства (systemd, библиотеки).
	3 - Внутри ядра: подсистема управления процессами, подсистема виртуальной памяти, сетевая подсистемка, драйверы устройств.
	4 - Внутри подсистемы памяти: менеджер страниц, аллокаторы, кэши.

	2) Относительность выбора элементарных компонентов (Relative Primitives)
	Как правило, наблюдатель произвольно решает, какие компоненты в данной системе считать элементарными
	3) Разделение обязанностей (Separation of Concerns)
	Связи внутри компонентов обычно сильнее, чем связи между компонентами (связность и увязка). Это разделение между
	внутри- и межкомпонентными взаимодействиями позволяет провести разделение обязанностей (separation of concerns) 
	между частями системы и изучать их по отдельности.
	4) Общие шаблоны (Common Patterns) Иерархические системы обычно состоят из немногих типов подсистем, по-разному скомбинированных и организованныхъ
	5) Любая работающая сложная система является результатом развития работавшей более простой системы
	Примеры: 
	Telegram 
	1. иерахрия: само пользовательское приложение - серверная инфраструктура - "подкапотное" - система UI/UX, сетевое взаимодействие
	(в котором: модуль шифрования, сериализации/десериализации)
	2. Относительность выбора: для пользователя - чат, для дизайнера - UI-компонет.
	3. Разделение обязанностей: сервер отвечает - маршрутизация сообщений, хранение истории в облаке, управление контактами.
	Служба уведомлений (Apple/Google) - доставка push-уведомлений на устройство, даже когда клиентское приложение свернуто.
	4. Клиент-серверная архитектура, шаблон "Кэш" и т.д.
	5. Первая версия Telegram была предельно простой, потом - изображения, групповые чаты, олосовые сообщения, видеозвонки, и т.д до 
	монетизации и звёздочек
	
	Какой-нибудь сайт для заказа услуг
	1. Иерархичность Сайт - Страницы (Главная, Услуги, Контакты) - Блоки страницы (шапка, текст, форма) - HTML-теги, CSS-стили.
	2. Для пользователя примитив — «страница». Для верстальщика — «блок» (<div>). Для браузера — DOM-элемент. Для сервера — HTML-файл.
	3.Разделение обязанностей. HTML — структура, CSS — внешний вид, JavaScript — интерактивность, сервер — отдача файлов. Изменение CSS не ломает HTML.
	4.Общие шаблоны. Сетка (grid/flexbox) для layout, модульные блоки, форма обратной связи — типовые решения, повторяющиеся на всех страницах.
	5. Развитие из простой системы. Сначала была одна HTML-страница «Hello World». Потом добавили CSS, затем ещё страниц, потом форму заказа, поздно — CMS.

	ОС 
	1. Иерархичность: Вся ОС -  Ядро - управление памятью, процессами, драйверы
	2.Относительные примитивы: Для пользователя: «программа». Для разработчика: «системный вызов». Для ядра: «прерывание», «дескриптор процесса»
	3. Разделение обязанностей. Ядро управляет железом, системные утилиты — настройкой, приложения — работой пользователя. 
	Драйвер мыши не знает о существовании файловой системы.
	4. Общие шаблоны. Файловая система VFS — единый интерфейс для разных ФС.
	Драйверная модель — все драйверы работают через стандартные интерфейсы ядра.
	Процессы — у всех есть PID, дескрипторы, контекст выполнения.
	5. Развитие из простой системы. Linux 1.0 (1994) (поддерживал только i386, одна файловая  система, 
	простейшее планирование процессов. Постепенно (в различных дистрибутивах по-разному) постепенно добавились: 
	множество архитектур (ARM, x86_64, RISC-V), разнообразие файловых систем (ext4, Btrfs, XFS, ZFS) и т.д.
