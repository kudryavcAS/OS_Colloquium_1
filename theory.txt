1.	ООП
	ООП - объектно-ориентированное программирование - наиболее часто определяется как методология программирования,
	при которой программа рассматривается как совокупность взаимодействующих объектов. 
	Ключевые принципы ООП — это абстракция, инкапсуляция, наследование и полиморфизм. При более близком рассмотрении, например, простейшего случая 
	инкапсуляции на примере одного поля можно земетить что число строк кода возрасло, а поле всё ещё можно читать и изменять (сеттеры, геттеры). 
	Получается что инкапсуляция в первую очередь нужна для сокрытия изменчивости, а не сложности. Так, например, может понадобится внедрить
	более сложную логику вычисления данного поля, для чего будет достаточно изменить реализацию геттеров и сеттеров, вызываемых в коде.
	Наследоваение и полиморфизм можно рассматривать как частный случай инкапсуляции. При дальнейшом рассмотрении можно придти к выводу, что
	ООП, в первую очередь, - инструмент борьбы с доменной сложностью.
2.	Объектно-ориентированная декомпозиция.	
	Объектно-ориентированная декомпозиция - декомпозиция, при которой проектируемая система логически представляется в виде суммы 
	отдельных частей (средствами ООП), взаимодействующих между собой. Часто эта декомпозиция производится не произвольно, а 
	по определённым шаблонам, с помощью использованием нескокльких десятков популярных 
	шаблонов проектирования (design patterns).
3.	Дизайн ПО
	Дизайн ПО - это план, иначе говоря, структура компонентов системы, определяющая их взаимодействие и распределение ответственности 
	для управления сложностью и достижения требуемых характеристик.
	Примеров дизайна ПО могут служить шаблоны проектирования (design patterns). Они задают струткуру компонентов (данных, классов)
	и их взаимодействия. Рассмотрим дизайн на примере поведенческого паттерна Стратегия, который определяет семейство схожих алгоритмов 
	и помещает каждый из них в собственный класс, после чего алгоритмы можно взаимозаменять прямо во время исполнения программы.
	1) Структурный дизайн - из чего состоит система. Может быть один класс/алгоритм имеющий много мктодов для разных входных данных и сложную 
	логику их выбора, а можно задать интерфейс и унаследовать от него конкретные узкоспециализированные классы (выполняется принцип разделения
	ответственности, своего рода реализации стратегии "разделяй и властвуй")
	2) Поведенческий дизайн - дизайн взаимодействия компонентов (наследование, включение и т.д.). Паттерн Стратегия позволяет динамически
	менять поведение. например метод
			setStrategy(Strategy strategy) {
				this.strategy = strategy;
			}
	3) Дизайн сопутсвует расширяемости функционала - легко добавить ещё один класс, реализующий конктреный алгоритм.






	с